# -*- coding: utf-8 -*-
"""MMdetectionToPytorch

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PujdC-vCAcixm7bplVmCkYWsgHFI6UgW
"""

import torch
import torchvision.transforms.functional as F
import torchvision
from torchvision.models.detection.faster_rcnn import FastRCNNPredictor

class LoadCVModel():
    def __init__(self, device):
        """
        Device (cuda string) and path to load CV Model (String)
        """

        self.model = torchvision.models.detection.fasterrcnn_resnet50_fpn_v2(pretrained=True)
        # get the number of input features 
        in_features = self.model.roi_heads.box_predictor.cls_score.in_features
        # define a new head for the detector with required number of classes
        self.model.roi_heads.box_predictor = FastRCNNPredictor(in_features, 2)

        self.device = device
        self.model.to(device)

        self.image_id = 0
    
    def predict_cv(self, images, batch_bboxes):
        """
        Takes in PIL img, its bboxes (list) and outputs the cv model losses
        """

        images = list(F.to_tensor(image).to(self.device) for image in images)

        targets = []

        for bboxes in batch_bboxes:
            bboxes = torch.as_tensor(bboxes, dtype=torch.float32).to(self.device)
            # area of the bounding boxes
            area = (bboxes[:, 3] - bboxes[:, 1]) * (bboxes[:, 2] - bboxes[:, 0]).to(self.device)
            # no crowd instances
            iscrowd = torch.zeros((bboxes.shape[0],), dtype=torch.int64).to(self.device)
            # labels to tensor
            labels = torch.ones(len(bboxes), dtype=torch.int64).to(self.device)

            target = {"boxes": bboxes, "labels": labels, "area": area, "iscrowd": iscrowd, "image_id": self.image_id}
            self.image_id += 1

            targets.append(target)
        
        loss_dict = self.model(images, targets)

        return loss_dict
