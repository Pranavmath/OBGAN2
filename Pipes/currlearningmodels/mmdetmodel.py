# -*- coding: utf-8 -*-
"""MMdetectionToPytorch

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PujdC-vCAcixm7bplVmCkYWsgHFI6UgW
"""

import torch
import torchvision.transforms.functional as F
from mmdet.structures import DetDataSample
from mmengine.structures import InstanceData

class LoadCVModel():
    def __init__(self, model, device):
        """
        Device (cuda string) and path to load CV Model (String)
        """
        self.model = model
        self.device = device
        self.model.to(device)
    
    def predict_cv(self, img, gt_bboxes, gt_labels):
        """
        Takes in PIL img, its bboxes (list) and labels (list) and outputs the cv model losses
        """
        torch_img = F.pil_to_tensor(img)
        x = torch.stack([torch_img.to(self.device).float()])

        """
        The DetDataSample must follow this format:
        <DetDataSample(

            META INFORMATION
            img_shape: _
            scale_factor: _

            DATA FIELDS
            batch_input_shape: _
            gt_instances: <InstanceData(

                    META INFORMATION

                    DATA FIELDS
                    bboxes: _
                    labels: _
                ) at _>
        ) at _>
        """
        y = DetDataSample(metainfo={"img_shape": img.size, "scale_factor": (1, 1)})
        y.batch_input_shape = img.size

        gt_instances = InstanceData()
        gt_instances.bboxes = torch.tensor(gt_bboxes).to(self.device)
        gt_instances.labels = torch.tensor(gt_labels).to(self.device)

        y.gt_instances = gt_instances

        loss = self.model.loss(x, [y])

        return loss
